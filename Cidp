{
  "hub_port": 8080,
  "cidp": {
    "client_id": "YOUR_CLIENT_ID",
    "client_secret": "YOUR_CLIENT_SECRET",
    "metadata_url": "https://cidp.example.com/.well-known/openid-configuration",
    "auth_endpoint": "https://cidp.example.com/adfs/oauth2/authorize",
    "token_endpoint": "https://cidp.example.com/adfs/oauth2/token",
    "redirect_uri": "http://yourserver:8080/callback"
  },
  "ad_groups": ["GG_App_Admins", "GG_App_Users"],
  "servers": ["xyzd4.abc.com", "xyzd5.abc.com"]
}


import json
import subprocess
import requests
import sys
from flask import Flask, render_template, request, redirect, session, url_for

app = Flask(__name__)
app.secret_key = 'generate-a-very-long-random-string-here'

def load_config():
    with open('config.json', 'r') as f:
        return json.load(f)

def check_ad_group(email):
    config = load_config()
    groups_str = "'" + "','".join(config['ad_groups']) + "'"
    # PowerShell checks if the email exists in AD and belongs to the groups
    ps_cmd = f"""
    $user = Get-ADUser -Filter "EmailAddress -eq '{email}'" -Properties memberOf
    if ($user) {{
        foreach ($g in @({groups_str})) {{
            if ($user.memberOf -like "*$g*") {{ return "Authorized" }}
        }}
    }}
    return "Denied"
    """
    try:
        res = subprocess.run(["powershell", "-Command", ps_cmd], capture_output=True, text=True)
        return "Authorized" in res.stdout
    except:
        return False

@app.route('/')
def index():
    if 'user_email' not in session:
        return redirect(url_for('login'))
    return render_template('index.html', user=session['user_email'])

@app.route('/login')
def login():
    config = load_config()['cidp']
    # Redirect user to CIDP Login
    params = {
        "client_id": config['client_id'],
        "response_type": "code",
        "scope": "openid email profile",
        "redirect_uri": config['redirect_uri']
    }
    auth_url = f"{config['auth_endpoint']}?{'&'.join([f'{k}={v}' for k, v in params.items()])}"
    return redirect(auth_url)

@app.route('/callback')
def callback():
    config = load_config()['cidp']
    code = request.args.get('code')
    
    # 1. Exchange Code for Token using Client Secret
    token_data = {
        "grant_type": "authorization_code",
        "code": code,
        "redirect_uri": config['redirect_uri'],
        "client_id": config['client_id'],
        "client_secret": config['client_secret']
    }
    
    token_res = requests.post(config['token_endpoint'], data=token_data).json()
    
    # 2. Extract email (usually from ID Token or UserInfo endpoint)
    # This part depends on your CIDP response structure; often it's a JWT.
    # For many CIDPs, we can get it from a 'id_token' or a separate /userinfo call.
    user_email = token_res.get('email') or "unknown@company.com" 

    # 3. Final Authorization Check (AD Group)
    if check_ad_group(user_email):
        session['user_email'] = user_email
        return redirect(url_for('index'))
    else:
        return "Access Denied: Not in AD Group.", 403

@app.route('/logout')
def logout():
    session.clear()
    return "Logged out."

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8080)

    
<!DOCTYPE html>
<html>
<head>
    <title>Process Monitor</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
</head>
<body id="mainBody" style="display:none;">

    <nav class="navbar navbar-dark bg-dark px-3 mb-4 shadow">
    <span class="navbar-brand fw-bold">Process Monitor</span>
    <div class="ms-auto d-flex align-items-center">
        <span class="text-white-50 me-3 small">Logged in: <strong>{{ user }}</strong></span>
        <a href="/logout" class="btn btn-sm btn-outline-danger">Logout</a>
    </div>
</nav>

    <div class="container mt-4">
        </div>

    <script>
        const config = {{ config | tojson }};

        async function initAuth() {
            // 1. Check if we have a token in URL (callback) or local storage
            // In a real SPA, you would use a library like MSAL.js or oidc-client
            // Here is the logic flow:
            
            let userEmail = sessionStorage.getItem("user_email");

            if (!userEmail) {
                // Trigger CIDP Login Redirect if no session exists
                const cidpUrl = `${config.cidp_settings.auth_url}?client_id=${config.cidp_settings.client_id}&response_type=id_token&redirect_uri=${encodeURIComponent(config.cidp_settings.redirect_uri)}&scope=openid email`;
                
                // For simplicity in this environment, we assume the user is redirected back with identity
                // If you are already logged into Windows, CIDP often passes this automatically via NTLM/Kerberos
                
                // MOCK: In your real environment, the CIDP will return a 'token'
                // For this example, let's assume your CIDP provides the identity:
                window.location.href = cidpUrl; 
                return;
            }

            // 2. Once CIDP returns the email, verify with our Hub
            const response = await fetch('/verify-token', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ email: userEmail })
            });

            const result = await response.json();
            if (result.success) {
                document.getElementById('userDisplay').innerText = result.user;
                document.getElementById('mainBody').style.display = 'block';
            } else {
                document.body.innerHTML = `<h2 class="text-danger p-5">${result.message}</h2>`;
                document.body.style.display = 'block';
            }
        }

        window.onload = initAuth;
    </script>
</body>
</html>

